/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { HotschedulesToast } from "@fern-api/toast";

/**
 * Information about a modifier option configured for this restaurant.
 *
 */
export interface ModifierOption {
    /**
     * An integer identifier that is used to refer to this modifier option by modifier option groups that contain it.
     *
     */
    referenceId?: number;
    /**
     * A descriptive name for this modifier option, for example, "Cheese" or "Pepperoni".
     *
     */
    name?: string;
    /**
     * A unique identifier for this modifier option's item reference, assigned by the Toast POS system. For a detailed description of a modifier option's item reference, see <a href="https://doc.toasttab.com/doc/platformguide/adminPricingModifierOptions.html#adminUnderstandingAModifierOptionsItemReference">Understanding a modifier optionâ€™s item reference</a> in the Toast Platform Guide.
     *
     */
    guid?: string;
    /**
     * An identifier that is used to identify and consolidate menu entities that are versions of each other. `multiLocationId` replaces `masterId`. `multiLocationId` and `masterId` always have the same value. Menu entities can be versioned. Those versions can be assigned to specific restaurant locations, or groups of locations, in a management group. For example, you could have two versions of a burger, one for a Boston location and another for a New York City location. Versioned menu entities share the majority of, but not all of, their data. For example, the Boston version is called the Minuteman Burger and has pickles, while the New York City version is called the Empire Burger and does not. You use the `multiLocationId` to identify menu entities that are versions of each other. To continue the example above, the Minuteman Burger in the JSON returned for the Boston location has the same `multilocationId` as the Empire Burger in the JSON returned for the New York City location. These matching `multlocationId` values indicate that the two items are related versions of the same item. In Toast reports, this allows a restaurant to track sales of the burger across both locations. The Toast POS system ensures that once a `multilocationId` value is assigned to a set of versions within a management group, that `multiLocationId` is not used for any other version sets in the same management group. It does not guarantee, however, that the `multiLocationId` is not used by another management group to identify a set of versions within it. For detailed information on the enterprise module and versioning, see <a href="https://doc.toasttab.com/doc/platformguide/sharingMenusAndOtherInformationAmongRestaurants.html">Enterprise module overview</a> in the Toast Platform Guide.
     *
     */
    multiLocationId?: string;
    /**
     * This value is deprecated. Instead of `masterId`, use `multiLocationId`. An identifier that is used to identify and consolidate menu entities that are versions of each other.
     *
     */
    masterId?: number;
    /**
     * An optional short description of this modifier option.
     *
     */
    description?: string;
    /**
     * The URL to an image that has been uploaded for this menu entity. This value is null if no image has been specified.
     *
     */
    image?: string;
    /**
     * An array of strings that indicate where this menu entity is visible: * POS: The menu entity is visible in the Toast POS app.  * KIOSK: The menu entity is visible on a Toast kiosk.  * TOAST_ONLINE_ORDERING: The menu entity is visible in the Toast online
     *   ordering site for this restaurant.
     * * ORDERING_PARTNERS: The restaurants wants this menu entity to be visible
     *   on online ordering sites that integrate with the Toast POS system using the orders API.
     * * GRUBHUB: Deprecated. The menu entity is included during a menu sync to
     *   Grubhub and will be visible on the Grubhub online ordering service after a
     *   menu sync has completed. _Note:_ Conceptually, the _Grubhub_ configuration
     *   option that was associated with the `GRUBHUB` string in this array has
     *   been replaced by the more general _Online orders: Ordering partners_
     *   configuration option and restaurants that used the _Grubhub_ option have
     *   been automatically migrated to the new _Online orders: Ordering partners_
     *   option. This means that any menu entity that had the _Grubhub_ option set
     *   to _Yes_ will now have the _Online orders: Ordering partners_ option
     *   enabled and the `ORDERING_PARTNERS` enum will be present in the
     *   `visibility` array for it. To support backwards compatibility, the
     *   `visibility` array for these entities will also continue to contain the
     *   `GRUBHUB` enum for a short period of time. See <a
     *   href="https://doc.toasttab.com/doc/devguide/apiDeprecatedApiFunctions.html#apiMenuEntityVisibilityEnhancements">Menu
     *   Visibility Enhancements (Rolled Out)</a> for more information.
     * The `visibility` array is empty if the menu entity is not configured to be visible for any of the use cases listed above.
     *
     */
    visibility?: HotschedulesToast.menus.MenuEntityVisibility[];
    /**
     * The price of this modifier option. In the Toast administration back-end, a modifier option may:
     *   * Inherit its price from a parent modifier group.
     *   * Use the price specified for its modifier option <a href="https://doc.toasttab.com/doc/platformguide/adminPricingModifierOptions.html#adminUnderstandingAModifierOptionsItemReference">item reference</a>.
     *   * Specify a price that overrides the price defined for its item reference.
     * The `price` value is populated differently depending on which of these pricing scenarios is used for the modifier option. The sections below describe how the `price` value is populated in these different scenarios. _Note:_ To determine how a modifier option has been priced, you can inspect the modifier option's `pricingStrategy` value. If it is GROUP_PRICE, then the modifier option is inheriting its price from a parent modifier group. If it is any value other than GROUP_PRICE (for example, MENU_SPECIFIC_PRICE or TIME_SPECIFIC PRICE), then the modifier option is using either the price specified for its item reference or an override price (override prices always use the BASE_PRICE strategy). _Modifier Option Inherits Its Price from a Parent Modifier Group_ If the modifier option inherits its price from a parent modifier group and that group uses the:
     *   * Fixed Price pricing strategy, then the modifier option's `price` value is populated with the fixed price specified for the parent modifier group. No additional calculations are required.
     *   * Size Price, Sequence Price, or Size/Sequence pricing strategy, then the modifier option's `price` value is null. You must use the _parent modifier group's_ `pricingStrategy` and `pricingRules` values to calculate the modifier option's price.
     * _Modifier Option Specifies an Override Price_ If the modifier option specifies an override price, the `price` value is set to that override price. No additional calculations are required. _Modifier Option Uses the Price from Its Item Reference_ If a modifier option uses the price from its underlying item reference, then the `price` value is populated using the same logic as the `price` value for a `MenuItem` object:
     *   * For base prices, the `price` value is populated with the specified base price.
     *   * For menu-specific prices, the `price` value is resolved based on the current menu. For example, consider a modifier option that is included in both Lunch and Dinner menus and is priced at $1 for the Lunch menu and $2 for the Dinner menu. In the fully resolved JSON returned by the menus API, this modifier option would appear twice, once as a child of the Lunch menu with a `price` value of $1, and again as a child of the Dinner menu with a `price` value of $2.
     *   If this same modifier option is added to a Breakfast menu but a menu-specific price is not defined for the Breakfast menu, then the `price` value for the instance of the modifier option that appears in the Breakfast menu JSON is populated with the base price from the menu-specific price configuration. Menu-specific price configurations include a base price that functions as a default price when a menu-specific price cannot be resolved.
     *   * For location-specific prices, the `price` value is resolved based on the current location. For example, consider a modifier option that costs $2 in the Boston location and $3 in the New York location. When you retrieve menu data for the Boston location, this modifier option's `price` value is $2. When you retrieve menu data for the New York location, the modifier option's `price` value is $3.
     *   * For time-specific prices, the `price` value is populated with the base price that is specified as part of the time-specific price configuration. This base price functions as a default price for the modifier option during times of the day when a time-specific price has not been defined. For example, consider a modifier option that costs $1 from noon to 2pm and $2 during the rest of the day. The `price` value for this item would be $2. You must use _this modifier option's_ `pricingStrategy` and `pricingRules` values to calculate the price of the modifier option during time periods for which a time-specific price has been defined.
     *   * For size prices, the `price` value is null. You must use _this modifier option's_ `pricingStrategy` and `pricingRules` values to calculate the price of the modifier option for different sizes.
     *   * For open prices, the `price` value is null.
     * If the modifier option is priced using a price level, the `price` value reflects the pricing strategy used for the price level, using the same logic described above. For example, consider a price level that applies a size price to the modifier option it is assigned to. In this case, the `price` value for the modifier option is null and you must use this modifier option's `pricingStrategy` and `pricingRules` values to calculate the price of the modifier option for different sizes. _Note:_ For detailed information on modifier option pricing and pricing strategies, see the <a href="https://doc.toasttab.com/doc/platformguide/adminToastPosPricingFeatures.html">Menu pricing</a> section in the Toast Platform Guide.
     *
     */
    price?: number;
    /**
     * A string that indicates how this modifier option has been priced. If `pricingStrategy` is:
     *   * GROUP_PRICE, then the modifier option inherits its price from a parent modifier group.
     *   * Any value other than GROUP_PRICE (for example, MENU_SPECIFIC_PRICE or TIME_SPECIFIC PRICE), then the modifier option is using either the price specified for its <a href="https://doc.toasttab.com/doc/platformguide/adminPricingModifierOptions.html#adminUnderstandingAModifierOptionsItemReference">item reference</a> or an override price (override prices always use the BASE_PRICE strategy).
     * If the modifier option is using the price of its underlying item reference, and that item reference is priced using the Location Specific Price pricing strategy, then the `pricingStrategy` value indicates which pricing strategy is used at the current location. For example, consider a modifier option that uses a menu-specific price at the Boston location and a base price at the New York location. When you retrieve the menu data for the Boston location, the `pricingStrategy` for the modifier option is MENU_SPECIFIC_PRICE. When you retrieve menu data for the New York location, the `pricingStrategy` for the modifier option is BASE_PRICE. If the modifier option is using the price of its underlying item reference, and that item reference is priced using a price level, then the `pricingStrategy` value indicates which pricing strategy is used for that price level. For example, if the "Special Toppings" price level uses a time-specific price, then the `pricingStrategy` value for a modifier option that is assigned the "Special Toppings" price level is TIME_SPECIFIC_PRICE. It is important to understand which `pricingRules` object to use when modifier option prices must be calculated. If the `pricingStrategy` value is:
     *   * BASE_PRICE or MENU_SPECIFIC_PRICE,  then you can retrieve the modifier option's price from its `price` value. No additional calculations are required.
     *   * GROUP_PRICE, then you must use the `pricingStrategy` and `pricingRules` values from _the modifier option's parent modifier group_ to calculate the modifier option's price.
     *   * TIME_SPECIFIC_PRICE or SIZE_PRICE, then you must use the rules provided in _this modifier option's_ `pricingRules` value to calculate the price for the modifier option.
     *
     */
    pricingStrategy?: string;
    /**
     * A `PricingRules` object with information about how to calculate the price for this modifier option. You use a modifier option's `pricingRules` object, in conjunction with its `pricingStrategy` value, to calculate a price for the modifier option when the modifier option is Individually priced_ and its `price` value is null. _Note:_ If the modifier option is priced at the group level, you must use the `pricingRules` object of its parent modifier group to calculate its price. A modifier option is priced at the group level if its `pricingStrategy` value is GROUP_PRICE. The `pricingRules` object takes different forms depending on the pricing strategy configured for the modifier option. Use the `pricingStrategy` value to determine which pricing strategy has been used so that you can properly interpret the data in the `pricingRules` object. For the BASE_PRICE, and MENU_SPECIFIC_PRICE pricing strategies, the `pricingRules` object is null because you can retrieve the price from the `price` value without additional calculation. For the OPEN_PRICE pricing strategy, the `pricingRules` object is also null (the price of a modifier option whose item reference uses the Open Price pricing strategy is specified at the time that the modifier option is ordered). For the TIME_SPECIFIC_PRICE and SIZE_PRICE pricing strategies, the `pricingRules` object contains additional values that you use to calculate the modifier option's price.
     *
     */
    pricingRules?: HotschedulesToast.menus.PricingRules[];
    salesCategory?: HotschedulesToast.menus.SalesCategory;
    /**
     * The `taxInfo` value on the `ModifierOption` object has been deprecated. An upcoming release will introduce new configuration settings for the taxes on a modifier option. The `taxInfo` value will not accurately represent these additional configurations. Your integration should switch to using the `modifierOptionTaxInfo` value instead. See <a href="https://doc.toasttab.com/doc/devguide/apiUsingTaxInfoAndModifierOptionTaxInfoToCalculateTaxesForMenuItemsAndModOptions.html">Using taxInfo and modifierOptionTaxInfo to calculate taxes for menu items and modifier options</a> in the Toast Developer Guide for more information.
     *
     */
    taxInfo?: string[];
    modifierOptionTaxInfo?: HotschedulesToast.menus.ModifierOptionTaxInfo;
    /**
     * An array of `ItemTag` objects that are assigned to this modifier option. Item tags are used to assign identifying characteristics to a modifier option, for example, vegetarian, gluten-free, alcohol.
     *
     */
    itemTags?: HotschedulesToast.menus.ItemTag[];
    /**
     * The price lookup (PLU) code for this modifier option. The PLU code can contain both numbers and letters. This value contains an empty string if a PLU code has not been defined.
     *
     */
    plu?: string;
    /**
     * The stock keeping unit (SKU) identifier for this modifier option. The SKU identifier can contain both numbers and letters. This value contains an empty string if a SKU has not been defined.
     *
     */
    sku?: string;
    /**
     * The number of calories in this modifier option. The calories value can be any positive or negative integer, or zero. This value is null if a calories amount has not been configured for the modifier option.
     *
     */
    calories?: number;
    contentAdvisories?: HotschedulesToast.menus.ContentAdvisories;
    /** The unit of measure used to determine the price of the modifier option. For example, $10.00 per gram. */
    unitOfMeasure?: HotschedulesToast.menus.PriceUnit;
    /**
     * Indicates whether this modifier option is included on the menu item by default. Important:_ If a menu item is configured to use default modifiers and you submit an order to the orders API for that menu item but you omit those default modifiers, then the Toast POS system assumes you want to omit the default modifiers and they will not be included in the order. For example, consider a Burger menu item that has Lettuce and Tomato as default modifiers. If you submit an order to the orders API for the Burger menu item but omit the Lettuce and Tomato default modifiers in the request, the order ticket will include the Burger but not the Lettuce and Tomato modifier options.
     *
     */
    isDefault?: boolean;
    /**
     * Indicates whether the modifier option may be added to a menu item multiple times. If a modifier option belongs to a modifier group whose `isMultiSelect` value is FALSE, then the Toast POS system sets the modifier optionâ€™s `allowsDuplicates` value to FALSE to prevent more than one modifier option being selected for the group.
     *
     */
    allowsDuplicates?: boolean;
    /**
     * An array of `Portion` objects that define the portions that this modifier option can be added to. For example, for a pizza menu item, you could define 1st Half and 2nd Half portions and this modifier option could be added to either portion. See <a href="https://doc.toasttab.com/doc/platformguide/adminPortionsOverview.html">Portions overview</a> in the Toast Platform Guide for more information.
     *
     */
    portions?: HotschedulesToast.menus.Portion[];
    /**
     * An array of `referenceId`s for `ModifierGroup` objects. These objects define nested modifier groups contained in this modifier option. For example, you can have an entree that has a Sides modifier group that contains a Salad modifier option. The Salad modifier option has its own modifier group, Salad Dressing, that includes Ranch, Vinaigrette, and Blue Cheese modifier options. Salad Dressing is a nested modifier group and the individual salad dressings are nested modifier options.
     *
     */
    modifierGroupReferences?: number[];
}
